<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>橙色星尘 - 手势交互星球</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        /* 视频流隐藏，仅用于检测 */
        #video-input { position: absolute; transform: scaleX(-1); visibility: hidden; width: 200px; height: 150px; }
        
        /* 状态显示 */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; color: #fff;
            background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 10px;
            pointer-events: none; border-left: 4px solid #ff6600;
            z-index: 10;
        }
        .gesture-active { color: #ff6600; font-weight: bold; }
        
        /* 错误消息提示 */
        #error-msg {
            display: none; color: #ff4444; font-size: 12px; margin-top: 10px;
            padding: 5px; border: 1px dashed #ff4444;
        }
        
        #loading {
            position: absolute; inset: 0; display: flex; flex-direction: column;
            justify-content: center; align-items: center; background: #000;
            color: #ff6600; z-index: 1000; transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid #ff6600; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading">
    <div class="spinner"></div>
    <div id="loading-text">正在初始化星系磁场与手势识别...</div>
</div>

<video id="video-input" playsinline></video>
<div id="ui-panel">
    <h3 style="margin:0 0 10px 0">控制面板</h3>
    <div id="status-gesture">等待手势...</div>
    <div id="status-distance" style="font-size: 12px; margin-top:5px; color: #aaa;">距离: --</div>
    <div id="error-msg">未检测到摄像头，已进入演示模式。</div>
    <div style="font-size: 10px; margin-top:10px; color: #888;">
        提示:<br>
        - 握拳并拉远: 快速远离<br>
        - 五指张开靠近: 快速靠近<br>
        - 倾斜手掌: 旋转观察
    </div>
</div>

<div id="container"></div>

<!-- 引入依赖库 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    /**
     * 全局变量定义
     */
    let scene, camera, renderer, planetParticles, ring1, ring2;
    let videoElement = document.getElementById('video-input');
    let loadingScreen = document.getElementById('loading');
    
    // 交互状态
    let handData = {
        detected: false,
        isFist: false,
        isOpen: false,
        z: 0,
        angle: 0,
        prevZ: 0
    };

    // 摄像机参数
    const MIN_DISTANCE = 50;
    const MAX_DISTANCE = 500;
    let cameraDistance = 200;
    let cameraRotationY = 0;
    let cameraTargetRotationY = 0;
    let zoomVelocity = 0;

    /**
     * 初始化 Three.js 场景
     */
    function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        // 1. 创建星球粒子 (橙色)
        const planetCount = 8000;
        const planetGeometry = new THREE.BufferGeometry();
        const planetPositions = new Float32Array(planetCount * 3);
        const planetColors = new Float32Array(planetCount * 3);
        
        const colorBase = new THREE.Color(0xff6600);

        for (let i = 0; i < planetCount; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            const r = 40 * (0.85 + Math.random() * 0.15); 
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            planetPositions[i * 3] = x;
            planetPositions[i * 3 + 1] = y;
            planetPositions[i * 3 + 2] = z;

            const mixedColor = colorBase.clone().lerp(new THREE.Color(0xffaa00), Math.random() * 0.5);
            planetColors[i * 3] = mixedColor.r;
            planetColors[i * 3 + 1] = mixedColor.g;
            planetColors[i * 3 + 2] = mixedColor.b;
        }

        planetGeometry.setAttribute('position', new THREE.BufferAttribute(planetPositions, 3));
        planetGeometry.setAttribute('color', new THREE.BufferAttribute(planetColors, 3));

        const planetMaterial = new THREE.PointsMaterial({
            size: 1.2,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        planetParticles = new THREE.Points(planetGeometry, planetMaterial);
        scene.add(planetParticles);

        // 2. 创建星环粒子 (白色)
        function createRing(innerRadius, outerRadius, count, opacity) {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = innerRadius + Math.random() * (outerRadius - innerRadius);
                pos[i * 3] = Math.cos(angle) * r;
                pos[i * 3 + 1] = (Math.random() - 0.5) * 2.0;
                pos[i * 3 + 2] = Math.sin(angle) * r;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            return new THREE.Points(geo, new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.6,
                transparent: true,
                opacity: opacity,
                blending: THREE.AdditiveBlending
            }));
        }

        ring1 = createRing(60, 85, 3000, 0.4);
        ring2 = createRing(95, 120, 2000, 0.3);
        
        ring1.rotation.x = Math.PI * 0.2;
        ring2.rotation.x = -Math.PI * 0.15;
        
        scene.add(ring1);
        scene.add(ring2);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    /**
     * 初始化 MediaPipe 手势识别
     */
    function initHands() {
        try {
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const cameraFeed = new Camera(videoElement, {
                onFrame: async () => {
                    try {
                        await hands.send({image: videoElement});
                    } catch (e) {
                        console.error("Hands process error", e);
                    }
                },
                width: 640,
                height: 480
            });

            // 尝试启动摄像头，捕获 NotFoundError
            cameraFeed.start().catch(err => {
                console.warn("Camera access failed:", err);
                handleCameraError();
            });
            
            // 兜底方案：如果 5 秒后还没隐藏加载页，强制隐藏并提示错误
            setTimeout(() => {
                if (loadingScreen.style.opacity !== '0') {
                    handleCameraError();
                }
            }, 5000);

        } catch (globalErr) {
            console.error("Hands Initialization failed:", globalErr);
            handleCameraError();
        }
    }

    /**
     * 摄像头失败处理逻辑
     */
    function handleCameraError() {
        document.getElementById('error-msg').style.display = 'block';
        document.getElementById('status-gesture').innerText = "演示模式 (无手势输入)";
        hideLoading();
    }

    function hideLoading() {
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
            if (loadingScreen.parentNode) {
                loadingScreen.style.display = 'none';
            }
        }, 500);
    }

    /**
     * 处理识别结果
     */
    function onResults(results) {
        // 只要有结果返回，说明摄像头是正常的，隐藏加载页
        if (loadingScreen.style.opacity !== '0') hideLoading();

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            handData.detected = true;

            let openFingers = 0;
            [8, 12, 16, 20].forEach(tipIdx => {
                const tip = landmarks[tipIdx];
                const base = landmarks[tipIdx - 2];
                if (tip.y < base.y - 0.05) openFingers++;
            });

            handData.isOpen = openFingers >= 4;
            handData.isFist = openFingers <= 1;

            const dx = landmarks[5].x - landmarks[17].x;
            const dy = landmarks[5].y - landmarks[17].y;
            const distanceScale = Math.sqrt(dx*dx + dy*dy);
            
            handData.prevZ = handData.z;
            handData.z = distanceScale;

            const angle = Math.atan2(landmarks[17].y - landmarks[5].y, landmarks[17].x - landmarks[5].x);
            handData.angle = angle;

            updateUI();
        } else {
            handData.detected = false;
            updateUI();
        }
    }

    function updateUI() {
        const statusEl = document.getElementById('status-gesture');
        const distEl = document.getElementById('status-distance');
        
        if (!handData.detected) {
            statusEl.innerText = "未检测到手部";
            statusEl.className = "";
            return;
        }

        if (handData.isFist) {
            statusEl.innerText = "握拳 (拉远模式)";
            statusEl.className = "gesture-active";
        } else if (handData.isOpen) {
            statusEl.innerText = "张开 (靠近模式)";
            statusEl.className = "gesture-active";
        } else {
            statusEl.innerText = "正常 (旋转模式)";
            statusEl.className = "";
        }
        
        distEl.innerText = `距离系数: ${handData.z.toFixed(3)}`;
    }

    /**
     * 渲染循环与动画逻辑
     */
    function animate() {
        requestAnimationFrame(animate);

        if (handData.detected) {
            cameraTargetRotationY += (handData.angle + Math.PI/2) * 0.05;
            const deltaZ = handData.z - handData.prevZ;
            
            if (handData.isFist) {
                if (deltaZ < -0.001) {
                    zoomVelocity += 1.5;
                } else {
                    zoomVelocity *= 0.95;
                }
            } else if (handData.isOpen) {
                if (deltaZ > 0.001) {
                    const remaining = cameraDistance - MIN_DISTANCE;
                    zoomVelocity -= (remaining * 0.08); 
                } else {
                    zoomVelocity *= 0.9; 
                }
            } else {
                zoomVelocity *= 0.8;
            }

            cameraDistance += zoomVelocity;
            zoomVelocity *= 0.9;
        } else {
            // 演示模式下的缓慢旋转
            cameraTargetRotationY += 0.005;
        }

        cameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, cameraDistance));
        cameraRotationY += (cameraTargetRotationY - cameraRotationY) * 0.05;

        camera.position.x = Math.sin(cameraRotationY) * cameraDistance;
        camera.position.z = Math.cos(cameraRotationY) * cameraDistance;
        camera.position.y = Math.sin(cameraRotationY * 0.5) * 40;
        camera.lookAt(0, 0, 0);

        planetParticles.rotation.y += 0.001;
        ring1.rotation.y -= 0.003;
        ring2.rotation.y += 0.002;

        renderer.render(scene, camera);
    }

    // 启动系统
    initThree();
    initHands();
    animate();

</script>
</body>

</html>
